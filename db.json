{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/clexy/source/LICENSE","path":"LICENSE","modified":0,"renderable":1},{"_id":"themes/clexy/source/scripts/index.js","path":"scripts/index.js","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-114x114.png","path":"images/apple-touch-icon-114x114.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-120x120.png","path":"images/apple-touch-icon-120x120.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-144x144.png","path":"images/apple-touch-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-152x152.png","path":"images/apple-touch-icon-152x152.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-57x57.png","path":"images/apple-touch-icon-57x57.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-60x60.png","path":"images/apple-touch-icon-60x60.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-72x72.png","path":"images/apple-touch-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/apple-touch-icon-76x76.png","path":"images/apple-touch-icon-76x76.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/favicon-128.png","path":"images/favicon-128.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/favicon-96x96.png","path":"images/favicon-96x96.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/favicon-196x196.png","path":"images/favicon-196x196.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/main.png","path":"images/main.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/mstile-144x144.png","path":"images/mstile-144x144.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/mstile-150x150.png","path":"images/mstile-150x150.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/mstile-70x70.png","path":"images/mstile-70x70.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/mstile-310x150.png","path":"images/mstile-310x150.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/styles/normalize.css","path":"styles/normalize.css","modified":0,"renderable":1},{"_id":"themes/clexy/source/styles/screen.styl","path":"styles/screen.styl","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/mstile-310x310.png","path":"images/mstile-310x310.png","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/500.woff2","path":"fonts/fira/500.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/400.woff2","path":"fonts/fira/400.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300.woff","path":"fonts/opensans/300.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300.woff2","path":"fonts/opensans/300.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400.woff2","path":"fonts/opensans/400.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400.woff","path":"fonts/opensans/400.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300i.woff2","path":"fonts/opensans/300i.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400i.woff2","path":"fonts/opensans/400i.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600.woff2","path":"fonts/opensans/600.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700.woff","path":"fonts/opensans/700.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700.woff2","path":"fonts/opensans/700.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600i.woff2","path":"fonts/opensans/600i.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700i.woff2","path":"fonts/opensans/700i.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800.woff2","path":"fonts/opensans/800.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800i.woff2","path":"fonts/opensans/800i.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/400.woff","path":"fonts/fira/400.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/500.woff","path":"fonts/fira/500.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/700.woff","path":"fonts/fira/700.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/fira/700.woff2","path":"fonts/fira/700.woff2","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/300i.woff","path":"fonts/opensans/300i.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/400i.woff","path":"fonts/opensans/400i.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600.woff","path":"fonts/opensans/600.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/600i.woff","path":"fonts/opensans/600i.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/700i.woff","path":"fonts/opensans/700i.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800.woff","path":"fonts/opensans/800.woff","modified":0,"renderable":1},{"_id":"themes/clexy/source/fonts/opensans/800i.woff","path":"fonts/opensans/800i.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"3fc2e817771ca40fbdd4897f89214536082473e4","modified":1502948478000},{"_id":"themes/clexy/README.md","hash":"15bb2494d0dffcd6cb649807c4eb893344c7a39b","modified":1502061569000},{"_id":"themes/clexy/_config.yml","hash":"56cb7629de3f65024946361d99e5e13dc5565078","modified":1502061569000},{"_id":"themes/clexy/layout/_footer.jade","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1502061569000},{"_id":"source/_posts/3Sum.md","hash":"bcfa8a5c3062f09d90a232783f4d61f78233d8f7","modified":1502434543000},{"_id":"source/_posts/3SumClosest.md","hash":"29eff0b0d850f0dfc30791b0a3965737d8abed95","modified":1502516008000},{"_id":"source/_posts/4Sum.md","hash":"2b539a7877b242a9d1cccaeb54925b9c98b660fe","modified":1502520425000},{"_id":"source/_posts/AddTwoNumbers.markdown","hash":"4d1acef6d2593553d712eb260f42256c54249866","modified":1502064520000},{"_id":"source/_posts/Divide Two Integers.md","hash":"affa9adc390d41b0da6f6ab49a5a85b318ffc70f","modified":1502948484000},{"_id":"source/_posts/First Missing Positive.md","hash":"76ea5e6c24c7c18a4148d421694930127fb1d0ff","modified":1503125779000},{"_id":"source/_posts/Group Anagrams.md","hash":"7e30297966c7197e7f8263c0b8490bfe2d7170b3","modified":1503202558000},{"_id":"source/_posts/Longest Common Prefix.md","hash":"4c2f1385a1a483017dba4195e11e249aa43c4f71","modified":1502775936000},{"_id":"source/_posts/Longest Palindromic Substring.md","hash":"125a21c730c4a2418fc1bc622a4e881b974c882c","modified":1502179658000},{"_id":"source/_posts/Longest Substring Without Repeating Characters.markdown","hash":"dcd0648c0eeb7c057360abe8aef81c4854b00164","modified":1502179658000},{"_id":"source/_posts/Maximum Subarray.md","hash":"dbb886b0a2ad955e34be576ca9231ff00f5abec1","modified":1503202896000},{"_id":"source/_posts/Merge Two Sorted Lists.md","hash":"e32c7e90d56fdd812a0e3e11c11f4abd541edcc2","modified":1503124988000},{"_id":"source/_posts/Multiply Strings.md","hash":"cff2fd074bfd00afb86ca308235b9fee5b53b680","modified":1503382732000},{"_id":"source/_posts/Next Permutation.md","hash":"845cd1caaf7ee8ea0331b9c048ee90dbb0f168a9","modified":1503037747000},{"_id":"source/_posts/Permutations.md","hash":"02f2f023d2476006cbe456f1ca220a7a8e2199f7","modified":1503383920000},{"_id":"source/_posts/Remove Duplicates from Sorted Array.md","hash":"6e09a8f0db93e9554f4574ae0ef67392c032b693","modified":1502864464000},{"_id":"source/_posts/Remove Element.md","hash":"6a051d7340bbde9abb3807c5b378b3232e2d60b2","modified":1502948482000},{"_id":"source/_posts/Remove Nth Node From End of List.md","hash":"d2b97b0063f68d976b34141ed71d1ee228e9cc0f","modified":1502776975000},{"_id":"source/_posts/Reverse Integer.md","hash":"d9aaf1c4780d09efa261d5842ab7aea27fd90560","modified":1502344887000},{"_id":"source/_posts/String to Integer.md","hash":"abe2510d4952fa855591aab7a099c3dbc1435d33","modified":1502344825000},{"_id":"source/_posts/TwoSum.md","hash":"6ec8fdf5d95fcbbf8e3da675ec39a94c9431ec83","modified":1502064446000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1500849583000},{"_id":"themes/clexy/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1502061569000},{"_id":"themes/clexy/.git/config","hash":"0549c41106e737c1895da0343c0890b3771417b0","modified":1502061569000},{"_id":"themes/clexy/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1502061569000},{"_id":"themes/clexy/.git/index","hash":"91749bfb89ab410c1000e5566a2c15a2394a83b4","modified":1502062672000},{"_id":"themes/clexy/.git/packed-refs","hash":"17ab1e02e76c909d45386221cb760edde7903edb","modified":1502061569000},{"_id":"themes/clexy/layout/_comments.jade","hash":"4ac668fa7883ecb1ae8230d5f023e6936f17403a","modified":1502061569000},{"_id":"themes/clexy/layout/_content.jade","hash":"7ac2f38ef1eca875050ff5987c6dfa75396a4f58","modified":1502061569000},{"_id":"themes/clexy/layout/_head.jade","hash":"bb55ce904dfdbc31ebd5ab22245762659e71ba47","modified":1502061569000},{"_id":"themes/clexy/layout/_header.jade","hash":"afedad4b0d744c63e7794b9c559f4e6579d1b9b7","modified":1502061569000},{"_id":"themes/clexy/layout/_mixins.jade","hash":"fef1a26fef90db4c5f41e6c56cdbf284e6786b8a","modified":1502061569000},{"_id":"themes/clexy/layout/_scripts.jade","hash":"c89be1a457bcf0e5a465a9836d6a9197c020210c","modified":1502061569000},{"_id":"themes/clexy/layout/index.jade","hash":"17f6ec2ed0ab4e0fc6cf2007265e4ade41bc6714","modified":1502061569000},{"_id":"themes/clexy/layout/layout.jade","hash":"d97e0842a86732f4f54b5034ecad18ff15a5e232","modified":1502061569000},{"_id":"themes/clexy/source/.DS_Store","hash":"9689bc111a89f363aa75cc715beb4de13e3b26ff","modified":1502061941000},{"_id":"themes/clexy/source/LICENSE","hash":"e9ab7bdd15464935d25c238f307a1fa20759a7a5","modified":1502061569000},{"_id":"themes/clexy/source/scripts/index.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1502061569000},{"_id":"themes/clexy/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1502061569000},{"_id":"themes/clexy/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1502061569000},{"_id":"themes/clexy/.git/logs/HEAD","hash":"36ffc722e02522b2a9f3e09bd001544beb283f12","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-114x114.png","hash":"c8276ecddc610ff3d19808d5268b27dfbd1e902c","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-120x120.png","hash":"2d2d1995d982b7f2cae143783540b261a5caebf4","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-144x144.png","hash":"75c8f71990592ec2ccafabeb8de2ee624d7d432f","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-152x152.png","hash":"34b78ba88cbe96d159cab6e531fe8c398edc37f8","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-57x57.png","hash":"3aad1f5ab167c2dfa02d476353dbb401f17ab587","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-60x60.png","hash":"5248ff1eb1b7ea65155ae506070ec3d151f1fce8","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-72x72.png","hash":"8c17f59712942553d6d326a86340ffde18e00541","modified":1502061569000},{"_id":"themes/clexy/source/images/apple-touch-icon-76x76.png","hash":"2ebc1226c5640e2285b48ea50af7d624325a2ed4","modified":1502061569000},{"_id":"themes/clexy/source/images/favicon-128.png","hash":"5b2d400c7db321ce6b233de46fb696ba218bf64d","modified":1502061569000},{"_id":"themes/clexy/source/images/favicon-16x16.png","hash":"5e956d1a4321b2b1b3cc388016f7e754a897ac69","modified":1502061569000},{"_id":"themes/clexy/source/images/favicon-32x32.png","hash":"4c24eae0da91c62670ee6b0f6fc8a7671fb3f899","modified":1502061569000},{"_id":"themes/clexy/source/images/favicon-96x96.png","hash":"59dc1149fcc12139e59db2c357d82250be6e40f7","modified":1502061569000},{"_id":"themes/clexy/source/images/favicon-196x196.png","hash":"154b220eec554991d10b3da11a0eeb1267925a14","modified":1502061569000},{"_id":"themes/clexy/source/images/favicon.ico","hash":"17a847b6be406e5308921368c8badb6c296a5be1","modified":1502061569000},{"_id":"themes/clexy/source/images/logo.png","hash":"59dc1149fcc12139e59db2c357d82250be6e40f7","modified":1502061569000},{"_id":"themes/clexy/source/images/main.png","hash":"a6a103582037a5e0b43335370eb4f9a9ed8def83","modified":1502061569000},{"_id":"themes/clexy/source/images/mstile-144x144.png","hash":"75c8f71990592ec2ccafabeb8de2ee624d7d432f","modified":1502061569000},{"_id":"themes/clexy/source/images/mstile-150x150.png","hash":"0b4ccb912109566fbb60a3444da37d0ad2e228cb","modified":1502061569000},{"_id":"themes/clexy/source/images/mstile-70x70.png","hash":"5b2d400c7db321ce6b233de46fb696ba218bf64d","modified":1502061569000},{"_id":"themes/clexy/source/styles/_mixins.styl","hash":"9a6d2de6090e9d7ab140a8c95d634012b26031dd","modified":1502061569000},{"_id":"themes/clexy/source/images/mstile-310x150.png","hash":"c553816fb2ab63704ee8846af754d62abbd901ac","modified":1502061569000},{"_id":"themes/clexy/source/styles/normalize.css","hash":"02fe53286d071637534d5aa2c57c76c168c0d521","modified":1502061569000},{"_id":"themes/clexy/source/styles/screen.styl","hash":"18beca66fbef7d84fde94bdc617e390449e8abf9","modified":1502061569000},{"_id":"themes/clexy/source/images/mstile-310x310.png","hash":"3f9d9c684c50721ba9ef51fbd63b52e4f53eb841","modified":1502061569000},{"_id":"themes/clexy/.git/objects/02/19f04e006832659c4957e50b4ca05a2c88d9a9","hash":"3d3d3ea609245f23a8d08501a55379dd5cf40353","modified":1502061569000},{"_id":"themes/clexy/.git/objects/02/5d915034f58d1c71fac3fbc8fe97566e359f43","hash":"89a0aebf8647089e90b3401a5ce9f21f5a81a607","modified":1502061569000},{"_id":"themes/clexy/.git/objects/04/5b4a20d3ce9c0b13658f2dee8010d2281de018","hash":"06f675636a8758f421ed35e392ccdd9eb7f6981a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/04/f87eec2e958e8daa2c4f60e7505d621ef63b94","hash":"398bbae4a5cb7bedf5ff7f85ca1d46b60ee2abf8","modified":1502061569000},{"_id":"themes/clexy/.git/objects/04/aa5cd3870352827e37f8a7cf6abc0553a2f8de","hash":"9981e91f6e8e40772545a05f512ad52afd319238","modified":1502061569000},{"_id":"themes/clexy/.git/objects/0e/9bab7d9d809a1b2013000074011e1b548b598b","hash":"0688c1ea4bbc91694b864c40e4c876d31d20e087","modified":1502061569000},{"_id":"themes/clexy/.git/objects/09/296da36ffd0b762457cf31534c64fb4bf13f80","hash":"9e2db4743f56b32d115eb4945871ca729a7c6d2e","modified":1502061569000},{"_id":"themes/clexy/.git/objects/0f/e1457f9ce8e3f02632714c52a2340fdb593a68","hash":"b6324e8dd874fcad19c08452b21b374475195b61","modified":1502061569000},{"_id":"themes/clexy/.git/objects/10/c80dbaaaad84591f137d4b7be6e09785fee5be","hash":"1b0479d87993e6fa640f1a102660b50070b60590","modified":1502061569000},{"_id":"themes/clexy/.git/objects/18/bdef01703a346f669d4efac05e5aa3099f9d10","hash":"7eab119b7c01171cdac1202592202c337613c519","modified":1502061569000},{"_id":"themes/clexy/.git/objects/19/1573409a58c4ee12d39668f670bbc7ad97a584","hash":"617532879f54eb836f7390477eac529c84812b2a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/1d/c7d491dc81cdfc0b610b498c264c0e2897b790","hash":"c50999aa7e17b57eaf60c9817cdb2fb928a693c4","modified":1502061569000},{"_id":"themes/clexy/.git/objects/1d/769bc8bc5f588192393a8c2ecd091cc1f508bb","hash":"2ce8f7fc2558844bfe4999c088fd33c8a8faa560","modified":1502061569000},{"_id":"themes/clexy/.git/objects/22/0b2725346c08434cfcb6e2bdff3e65a1e2acb0","hash":"2575e34068d1b9b30f27d2d3a7413ed13e9ba1e7","modified":1502061569000},{"_id":"themes/clexy/.git/objects/26/d274484c569f1fd09a49fb55f8165dba7c5f90","hash":"5138cf0565a83c7ed95ca537c34519a48d08f564","modified":1502061569000},{"_id":"themes/clexy/.git/objects/35/041cd7848d50dd74bf4b6199a2350305f9906a","hash":"e71addb658c55a910ac5306b92dcb4920b032761","modified":1502061569000},{"_id":"themes/clexy/.git/objects/21/a92a7e8daf217e8d20e1ac47a121cfaf69a3a5","hash":"a3495fcf9459b878a6ba3053d81375af60bece88","modified":1502061569000},{"_id":"themes/clexy/.git/objects/36/a9d11fcdc19c2c12831ac3ceab9d6da8ef6fbc","hash":"6b023589eecc22c5c364e05061ae3072390ac616","modified":1502061569000},{"_id":"themes/clexy/.git/objects/3c/221ddc55502e30925345bb7924ccbdd2c1a11d","hash":"681cc36ee1e5e3368596381b9e425b9d33bc07c1","modified":1502061569000},{"_id":"themes/clexy/.git/objects/3e/153a05380b19abcb006699904bd1edd22b8c70","hash":"bd7d6085a9b6ec222abf92251ddf8ba4754cbf3d","modified":1502061569000},{"_id":"themes/clexy/.git/objects/3e/30e9b05e151714e6f837e2b816eaa3dac8b90a","hash":"f9fe4b387a35df5be8ee8e32428e49390f284abd","modified":1502061569000},{"_id":"themes/clexy/.git/objects/40/4da979ee91f1b62c2dc3e0646258a68058a6d3","hash":"1f1a4cd6bcf8167cf95d4e888749bd40a4c76599","modified":1502061569000},{"_id":"themes/clexy/.git/objects/40/66b6e20090c7e52f7f023743c754d19c3a012f","hash":"e90395fc3ca8733e5d3352dd9325b8aee6aef2a3","modified":1502061569000},{"_id":"themes/clexy/.git/objects/41/d85047e54e6f0cc480feb2432b3031edcaaa6b","hash":"6a3e4aa83d2a98ed607ff90bc12128f8eb7f8f47","modified":1502061569000},{"_id":"themes/clexy/.git/objects/44/9474e8c6a189cdc362b5be5ba287c46855c111","hash":"9fd3fe722b51857308e32d50f1f538188f509e54","modified":1502061569000},{"_id":"themes/clexy/.git/objects/45/8eea1ea3d5d57b8d35a7453763e681e4ffe383","hash":"f86d77269d828b2e9f2e049215e4e71dacdbb68b","modified":1502061569000},{"_id":"themes/clexy/.git/objects/46/748fe9129f725f1ab20ee9a286fa6c7f5cac17","hash":"0e35a465d5fc556c61dce956950f563ce61999ba","modified":1502061569000},{"_id":"themes/clexy/.git/objects/44/0b74c3910237b27f1db7d81f69dfbaef957566","hash":"154de3c61ecbfdcd25aaaae24144b94352876994","modified":1502061569000},{"_id":"themes/clexy/.git/objects/52/744ac8a0694265db012a126410c33858a58493","hash":"307b53a2e9e0dbc939d31dc64d7e994f06fcf984","modified":1502061569000},{"_id":"themes/clexy/.git/objects/55/007b3b574bb55e3523a12a5c6d8a7438cf8bdf","hash":"58cb04c9ea642da65412720d94d859c97c92a4f4","modified":1502061569000},{"_id":"themes/clexy/.git/objects/46/a52f95f20507ac3f66a31168115975d7bd24d6","hash":"f5853d8c26a5a9d29376972c8323a58d35e1f5c9","modified":1502061569000},{"_id":"themes/clexy/.git/objects/60/95844f27362bf64fb765f60f73daeeaebb83ff","hash":"5d2e092182108f209af6daeeae27f19b6eb550dd","modified":1502061569000},{"_id":"themes/clexy/.git/objects/60/d8de4f6443349c8ac683d019da037b1d7ab655","hash":"7779362645f50927da2e7659afde067d5afe6ea3","modified":1502061569000},{"_id":"themes/clexy/.git/objects/62/4836b7fd09a83c7eb6c27a9cd9feca7636b52a","hash":"f5eb17ab6395ac11bc346d5ff90329a669248194","modified":1502061569000},{"_id":"themes/clexy/.git/objects/61/0e9b2071ec1d6c47a7815010acb20f0abbdd98","hash":"94615b97f9869893020ac99ccc7ee0704253657d","modified":1502061569000},{"_id":"themes/clexy/.git/objects/64/f22b0a0d7fd1caa2ffcbcd567915be5da0b1df","hash":"5b167a9ad9d713efc408582c06ade5c6fe85a89c","modified":1502061569000},{"_id":"themes/clexy/.git/objects/64/bc7a8c6c14df32afd286041ef6c0c600775b4e","hash":"f92b31601902804b1495d699191e6c633c5c8f3a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/6b/ddedc0d719455c031a4fb44304133e0bf14613","hash":"a1161a4aec671c8a7e43427bc21b0ebc9e6961c0","modified":1502061569000},{"_id":"themes/clexy/.git/objects/6b/e4c523199485a1bba604aaad50f0bdb4076e49","hash":"e67147fb4994b1e18253b73e4e0b53e029e9e1f7","modified":1502061569000},{"_id":"themes/clexy/.git/objects/6d/5d4305e2ea09db388f309f78411177c7c8ad95","hash":"fbacc19692e2a47e37327139a40ac262c2d4a960","modified":1502061569000},{"_id":"themes/clexy/.git/objects/6e/4793d27dd11c41eae3e708ef11f2bd4ff6cd5c","hash":"09f7c27053f43782bd410f4ebdbfd0b265147e9d","modified":1502061569000},{"_id":"themes/clexy/.git/objects/74/4203b06d0839c656c0876b00ea74a8af02f1c6","hash":"e8ddd37e28ff1098236c6ade9923f3076595dbd2","modified":1502061569000},{"_id":"themes/clexy/.git/objects/77/731de891129bcdf575598bf5921bd96ae88928","hash":"8eb9cfcd577682a757ffa7e4eb1343422cda6397","modified":1502061569000},{"_id":"themes/clexy/.git/objects/7b/700427e2cb5f6faa426245fac612c7dec4b346","hash":"933b8cf846544a26af0a1a2c90d3879943856818","modified":1502061569000},{"_id":"themes/clexy/.git/objects/83/9cfe7421aa0c757c31bbf5c37134038e54abf4","hash":"af629ccfaba6dd7ff26eceef424f308e4189e94e","modified":1502061569000},{"_id":"themes/clexy/.git/objects/85/2f7106cea5622e71238502baafbd689c2619be","hash":"794ad73d6cf109cfc7285b28533072e78ca2cd86","modified":1502061569000},{"_id":"themes/clexy/.git/objects/87/20c77e94e7b619970d353720413e42d8a91e0c","hash":"1d073e5cdf15678d3cb782d12ee72c7a416220b5","modified":1502061569000},{"_id":"themes/clexy/.git/objects/8f/e452a3ee6113a1ae1aa102971b59dfdc90dadd","hash":"6aa108de5b6f520cded5f7d81331d32cabb95baa","modified":1502061569000},{"_id":"themes/clexy/.git/objects/90/93462c36172f0c54b95eaa0792aeaccfea3402","hash":"1421754df6f7a5488d037cb4846b6f011fa73c61","modified":1502061569000},{"_id":"themes/clexy/.git/objects/a4/010dc772ada579a63325baf9c472215868e504","hash":"7967cbce2d0b0268d1251fdcb2869448150fb587","modified":1502061569000},{"_id":"themes/clexy/.git/objects/a6/21d94f066187ffaf3f907a337b539208f75be3","hash":"36e0d3a085066f9a8bd5d4f0c55f1ebcee724c14","modified":1502061569000},{"_id":"themes/clexy/.git/objects/a7/3b426fae6c1b5862fef20790b56253ba24ea21","hash":"d9c08e8c92a9f86eb73ae2135025dccb69999ca5","modified":1502061569000},{"_id":"themes/clexy/.git/objects/9f/a44b7cc2d38680bc14df07ddf3f6b320740da5","hash":"6473ce71f8e7fdf6296369e89025617903906580","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ac/f2d6650735ce3305777853ae5177ac5510cb9c","hash":"504244bc179d3471978e5b61409b3ad5261e6067","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ae/0d08e068e9b735a13d02de70de9139d7b50a01","hash":"144d6e246c305414462b83620aab34a6b92e6e11","modified":1502061569000},{"_id":"themes/clexy/.git/objects/b1/c4625c46cb91a6b1fd6693d2452705e58be832","hash":"4af2935a1f2ee957f03b447192950450bde8b83a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/b0/d4a6557ac193f35307a77ee4a6ed14bebbe028","hash":"681f1d02e840225d21d03ffe7bcb9ddbd3e95e92","modified":1502061569000},{"_id":"themes/clexy/.git/objects/b0/c2a26b40c91de96e2754bc57afae5ad0893dbb","hash":"c739772e92f1f4ac9856c3f7338a37f54f839434","modified":1502061569000},{"_id":"themes/clexy/.git/objects/b4/ef09af0aa12a5b7cf4dbb9b75cc0afd6b14c45","hash":"f1a539b2c2998a8baa24e33c79707d440b33cfd6","modified":1502061569000},{"_id":"themes/clexy/.git/objects/c0/3f2d443d076e1e492839c22e50d1851a6c6d45","hash":"fcba5e0259239dea8b239bf49061ad5454ffb5ff","modified":1502061569000},{"_id":"themes/clexy/.git/objects/c0/8bf1ba2b12bdfa9a651a26dac6d1ee62e54fe0","hash":"e5d115c80bc44fc23358ce6a29e7107a41d9bf8e","modified":1502061569000},{"_id":"themes/clexy/.git/objects/bb/aa1d4ea68741f3058cbd8efc726bee9ba5f28d","hash":"f563cd222777506dbc98739c7f46c9ae1a338f9a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ca/645e68008d3942d27810af4f1ba00dd7526997","hash":"fa2e20dbf45724653363874e6d85caa2559b8f39","modified":1502061569000},{"_id":"themes/clexy/.git/objects/c8/0b2d2afb71e4ab1809f7959314416cf66cb82c","hash":"532c46b0286c15f81168de6f839cc3e6bba8e0e8","modified":1502061569000},{"_id":"themes/clexy/.git/objects/bd/0f824b207d6007f2164390dc9df31271c42119","hash":"a3221b0dc7d893263ce973e04305f088604ce06a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/cf/e600a4e49414674c30881c3b5cfb464157fa32","hash":"64a58b74d5be64f8bb9a249867e227df36c6eb27","modified":1502061569000},{"_id":"themes/clexy/.git/objects/d6/595ad321add85957b2303aca9590602977aa26","hash":"5225aa92018e0db4e82bf28e189224ea08a9f87c","modified":1502061569000},{"_id":"themes/clexy/.git/objects/db/50a8d30e0a80cdea7b086d01f161a9bfa7e255","hash":"b750296af333bfd5186f4d2d9913eaace9777034","modified":1502061569000},{"_id":"themes/clexy/.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391","hash":"c2baae88d6364d878fd67e778c6a5d8306ad4ab0","modified":1502061569000},{"_id":"themes/clexy/.git/objects/c6/68e4537f9e95be9f967a0455038399fd250af9","hash":"476dfec170ef893118873d9e594b7e280178ffd5","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ed/7d5ee9c785cfa9c4fe3992940e12c0a897e84c","hash":"ed7f733ce8403a1d0ff8ca7e5b0b28c7fe763750","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ee/2b99259b6f702e5ab612bfef1f2c1278fab9d9","hash":"509a96ee3c5481b416914ebf10e24e429db02cd5","modified":1502061569000},{"_id":"themes/clexy/.git/objects/f1/7b772e7c1d2e68d929925b3d761a3c6e01501d","hash":"d14baaad891df63aa7f12e252600b17dc0bf143b","modified":1502061569000},{"_id":"themes/clexy/.git/objects/f6/ac08d24fe7853383593d9a11cda21c3fd26e7e","hash":"47767adcb08234bd7113ef6ef932d3097f12fa6a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/d0/b43e0adf956ae858ca94f0fb821ffbecfe3dd3","hash":"9fb589d0c0cbeec989e60899a7ecc0335080a382","modified":1502061569000},{"_id":"themes/clexy/.git/objects/f9/f1bd12600da251f56811e61c7c3c2c7c03d647","hash":"c3645da57ff75c32a87f7c3fc11ff8596b977ea6","modified":1502061569000},{"_id":"themes/clexy/.git/objects/f9/f98ab6ecfa8aff5ebeb5112de8f7476d18e8b4","hash":"1e44e56235f58e80aa6230a2aa73df8cb938d108","modified":1502061569000},{"_id":"themes/clexy/.git/objects/fe/e20b7f4055f312c040a2969f2e760f979ab487","hash":"41c71a22f876f2d0bdde77d911edf61bf068a838","modified":1502061569000},{"_id":"themes/clexy/.git/objects/f7/78f9c8455f265d05e653f5de4f4979fac4b4f3","hash":"7317cbbc640cea7d555da63b377e05f533d26b38","modified":1502061569000},{"_id":"themes/clexy/.git/objects/fa/3cfb7c43ed30b1972d3095984e2136a7250e69","hash":"1d9c7bfad6831268717e62b0cbe26ee83d9b934a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ff/71a4520a67b3d88f32cad2e1a22ea0aa22fe9e","hash":"8b14e04c2768cfdf37328f4fcb99a2155593c077","modified":1502061569000},{"_id":"themes/clexy/.git/refs/heads/master","hash":"7953347c9508b7fabf4ef804e5954e48f10a04f1","modified":1502061569000},{"_id":"themes/clexy/source/fonts/fira/500.woff2","hash":"86d5b01469d71971cb0aa0f6f6f7946c045ff628","modified":1502061569000},{"_id":"themes/clexy/source/fonts/fira/400.woff2","hash":"a8e246df0368fd8eef4806d9a1b36cf914beae15","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/300.woff","hash":"8578430db19589546f1be89d121016713c801d30","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/300.woff2","hash":"ad2af0f0a073835100e66ee93b50def2e57a28df","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/400.woff2","hash":"9b18ae04f11fc74d27f281737b23b45a4bad5937","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/400.woff","hash":"7dd17593d3947f4ea10be937634ef8f553443e5a","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/300i.woff2","hash":"d45729f6376fe48d2b8a2c611b651a7f1502ae01","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/400i.woff2","hash":"24cc685201e9dd17ba9fed66f61fa4626f83211b","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/600.woff2","hash":"931f5105f0e909f90bdea2e246a1a230809a699a","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/700.woff","hash":"7956fd048338c3c6253aa58f65442441866d4b4e","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/700.woff2","hash":"074d6e274d90a1b510d6eff3a5f8d26f567c1575","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/600i.woff2","hash":"e51180cddda569a91790c2dc4c352d06831bb07b","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/700i.woff2","hash":"649af46dba2ec76c793426335e4026ca6c7a6109","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/800.woff2","hash":"ee323b2accd80d6845d5cb1ba426bea25f087abe","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/800i.woff2","hash":"649af46dba2ec76c793426335e4026ca6c7a6109","modified":1502061569000},{"_id":"themes/clexy/source/images/avatar.jpg","hash":"e85eeb252efa43f7399202a54394a0e62d23b7f1","modified":1502061569000},{"_id":"themes/clexy/.git/objects/1e/d8ab956871438fd43751ee72c4013a0e386943","hash":"c74f2e5281111930fc937dbf86f1d033179fbd48","modified":1502061569000},{"_id":"themes/clexy/.git/objects/41/2a01bf019cd6fdfafa916f1bc3c190f6eb95ef","hash":"cb1a51d446c435b82b68b8413f2e1136bdfcdfab","modified":1502061569000},{"_id":"themes/clexy/.git/objects/73/5352fb939775e458bc370c3c1eb73e5b11ea90","hash":"13bf360d2fa14f673a6b4ada3936e346bb742e3b","modified":1502061569000},{"_id":"themes/clexy/.git/objects/83/2aaabbb237c095ecd3f6f68863ba02a5675f56","hash":"e3026a1deeaf634e1f96abbdec0573b732df8234","modified":1502061569000},{"_id":"themes/clexy/.git/objects/8c/0313ff36b3b3524737e0043faa5581c4eba19e","hash":"7350cc240bb0369fdeb060f9a9f4a4c4cb867da2","modified":1502061569000},{"_id":"themes/clexy/.git/objects/90/351a259f07e53ed021d440df965ed885b9b20b","hash":"ddd14b67ce6d1285a13ac0866ce19ffa8f9883ca","modified":1502061569000},{"_id":"themes/clexy/.git/objects/a3/3c7245c53775385751d9d34aea4ace2c92e914","hash":"f0d37d1772627c45b513f8043abec1e47485331a","modified":1502061569000},{"_id":"themes/clexy/.git/objects/b3/8ee144d028fc1530368c2112c15623a8ffbd19","hash":"d91403cfeed25559f25c422541bb71d587d78a9c","modified":1502061569000},{"_id":"themes/clexy/.git/objects/bc/83d1db5f0d0af5c2df5b8800d71c15113494c6","hash":"fc961589ccc3e14bd35d9a3541df2b8e7426f511","modified":1502061569000},{"_id":"themes/clexy/.git/objects/ce/d8f697114faa5e188414c045ad225cdc328de2","hash":"710ed29b7e9c77a693697e3c9349a69ef488aee5","modified":1502061569000},{"_id":"themes/clexy/.git/objects/fa/90b66e254dfc724bed752360c6e2573cc5de81","hash":"880294aa09998b077b2d7bad29ee48696ad674ab","modified":1502061569000},{"_id":"themes/clexy/source/fonts/fira/400.woff","hash":"4ee1b0356eac96f44b48a5ecc36584c4c81e33bd","modified":1502061569000},{"_id":"themes/clexy/source/fonts/fira/500.woff","hash":"5d4c15722ac01fb9c74662496967d6ebeda078d7","modified":1502061569000},{"_id":"themes/clexy/source/fonts/fira/700.woff","hash":"4b2ef8d1724a48a42afc5e7ff8ee77a960ed6895","modified":1502061569000},{"_id":"themes/clexy/source/fonts/fira/700.woff2","hash":"798f8fe64d02e466b546e16cf82a6ce914e96db5","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/300i.woff","hash":"dae3f536b867ea3d6cce0ef1406ab9b0813c16ea","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/400i.woff","hash":"9599e5da71b62e5227becb48e5498939e636e923","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/600.woff","hash":"7c9f1210d31388fe5df9e368bd0e73a8f4091b28","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/600i.woff","hash":"9406a2e087eb0d1790c2a7348b940f773ae6dda3","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/700i.woff","hash":"87f22f6a8759ae4bc18d97469091d9b218210b45","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/800.woff","hash":"31075459cd2010120a805d95506a9f8d7005b228","modified":1502061569000},{"_id":"themes/clexy/source/fonts/opensans/800i.woff","hash":"87f22f6a8759ae4bc18d97469091d9b218210b45","modified":1502061569000},{"_id":"themes/clexy/.git/logs/refs/heads/master","hash":"36ffc722e02522b2a9f3e09bd001544beb283f12","modified":1502061569000},{"_id":"themes/clexy/.git/objects/06/7fcf920640dc33d4c9321e8ae081ccf0471fcb","hash":"642245b0e272deff3ee090775f2122c446a6b184","modified":1502061569000},{"_id":"themes/clexy/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1502061569000},{"_id":"themes/clexy/.git/logs/refs/remotes/origin/HEAD","hash":"36ffc722e02522b2a9f3e09bd001544beb283f12","modified":1502061569000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"3Sum","_content":"\n### Problem:\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nNote: The solution set must not contain duplicate triplets.\n\n```\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n***\n\n### Analysis:\nSort the array and traverse the array from 0 ~ len(array) - 2. for each element i use i + 1 ~ len(array) - 2 do  2 sum. the new target is target - array[i]. repeat the process until find all solution. for each tuple i, j, k. if array[i]. Be careful the duplicates may cause duplicate solution.  Time complexity is O(n^2)\n\n***\n\n### Implementation:\n```\ndef threeSum(self, nums):\n    if len(nums) <3: \n        return []\n    elif len(nums) == 3:\n        if sum(nums) == 0:\n            return [sorted(nums)]\n    nums.sort()\n    res = []\n    for i in list(range(len(nums)-2)):\n        if i > 0 and nums[i] == nums[i-1]: # avoid duplication\n            continue\n        j = i + 1\n        k = len(nums) - 1\n        while j < k:\n            if j > i + 1 and nums[j] == nums[j-1]: # avoid duplication\n                j += 1\n                continue\n            if k < len(nums) - 1 and nums[k] == nums[k+1]: # avoid duplication\n                k -= 1\n                continue\n            if nums[i] + nums[j] + nums[k] == 0:\n                res.append([nums[i],nums[j],nums[k]])\n            if nums[i] + nums[j] + nums[k] < 0:\n                j += 1\n            else:\n                k -= 1\n    return res\n```","source":"_posts/3Sum.md","raw":"---\ntitle: 3Sum\n---\n\n### Problem:\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nNote: The solution set must not contain duplicate triplets.\n\n```\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n***\n\n### Analysis:\nSort the array and traverse the array from 0 ~ len(array) - 2. for each element i use i + 1 ~ len(array) - 2 do  2 sum. the new target is target - array[i]. repeat the process until find all solution. for each tuple i, j, k. if array[i]. Be careful the duplicates may cause duplicate solution.  Time complexity is O(n^2)\n\n***\n\n### Implementation:\n```\ndef threeSum(self, nums):\n    if len(nums) <3: \n        return []\n    elif len(nums) == 3:\n        if sum(nums) == 0:\n            return [sorted(nums)]\n    nums.sort()\n    res = []\n    for i in list(range(len(nums)-2)):\n        if i > 0 and nums[i] == nums[i-1]: # avoid duplication\n            continue\n        j = i + 1\n        k = len(nums) - 1\n        while j < k:\n            if j > i + 1 and nums[j] == nums[j-1]: # avoid duplication\n                j += 1\n                continue\n            if k < len(nums) - 1 and nums[k] == nums[k+1]: # avoid duplication\n                k -= 1\n                continue\n            if nums[i] + nums[j] + nums[k] == 0:\n                res.append([nums[i],nums[j],nums[k]])\n            if nums[i] + nums[j] + nums[k] < 0:\n                j += 1\n            else:\n                k -= 1\n    return res\n```","slug":"3Sum","published":1,"date":"2017-08-11T06:36:39.000Z","updated":"2017-08-11T06:55:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz470000ye8rney73lwo"},{"title":"4Sum","_content":"\n### Problem: \nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\nNote: The solution set must not contain duplicate quadruplets.\n\n```\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n***\n\n### Ayalysis:\nSimilar to 3sum problem. This kind of questions can be solved by k Sum problem.\n\nTo avoid duplicate list items, I skip unnecessary indices at two locations:\n\none at the end of the outer loop (i-loop)\nthe other at the end of the inner loop (j-loop).\nTo avoid useless computations, the following is kind of critical:\n\nthe function return immediately when nums[i]*4 > target\nthe inner loop break immediately when nums[j]*4 < target.\n\nTime Complexity is O(n^3)\n***\n\n## Implementation:\n\n\n### Iterative\n```\nclass Solution:\n# @return a list of lists of length 4, [[val1,val2,val3,val4]]\ndef fourSum(self, num, target):\n    two_sum = collections.defaultdict(list)\n    res = set()\n    for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\n        two_sum[i1+i2].append({n1, n2})\n    for t in list(two_sum.keys()):\n        if not two_sum[target-t]:\n            continue\n        for pair1 in two_sum[t]:\n            for pair2 in two_sum[target-t]:\n                if pair1.isdisjoint(pair2):\n                    res.add(tuple(sorted(num[i] for i in pair1 | pair2)))\n        del two_sum[t]\n    return [list(r) for r in res]\n```\n\n***\n\n### Recursive\n```\ndef fourSum(self, nums, target):\n    nums.sort()\n    results = []\n    self.findNsum(nums, target, 4, [], results)\n    return results\n\ndef findNsum(self, nums, target, N, result, results):\n    if len(nums) < N or N < 2: return\n\n    # solve 2-sum\n    if N == 2:\n        l,r = 0,len(nums)-1\n        while l < r:\n            if nums[l] + nums[r] == target:\n                results.append(result + [nums[l], nums[r]])\n                l += 1\n                r -= 1\n                while l < r and nums[l] == nums[l - 1]:\n                    l += 1\n                while r > l and nums[r] == nums[r + 1]:\n                    r -= 1\n            elif nums[l] + nums[r] < target:\n                l += 1\n            else:\n                r -= 1\n    else:\n        for i in range(0, len(nums)-N+1):   # careful about range\n            if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\n                break\n            if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\n                self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n    return\n```\n\n***\n\n### Revised\n```\ndef fourSum(self, nums, target):\n    def findNsum(nums, target, N, result, results):\n        if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\n            return\n        if N == 2: # two pointers solve sorted 2-sum problem\n            l,r = 0,len(nums)-1\n            while l < r:\n                s = nums[l] + nums[r]\n                if s == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif s < target:\n                    l += 1\n                else:\n                    r -= 1\n        else: # recursively reduce N\n            for i in range(len(nums)-N+1):\n                if i == 0 or (i > 0 and nums[i-1] != nums[i]):\n                    findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n\n    results = []\n    findNsum(sorted(nums), target, 4, [], results)\n    return results\n```","source":"_posts/4Sum.md","raw":"---\ntitle: 4Sum\n---\n\n### Problem: \nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\nNote: The solution set must not contain duplicate quadruplets.\n\n```\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n***\n\n### Ayalysis:\nSimilar to 3sum problem. This kind of questions can be solved by k Sum problem.\n\nTo avoid duplicate list items, I skip unnecessary indices at two locations:\n\none at the end of the outer loop (i-loop)\nthe other at the end of the inner loop (j-loop).\nTo avoid useless computations, the following is kind of critical:\n\nthe function return immediately when nums[i]*4 > target\nthe inner loop break immediately when nums[j]*4 < target.\n\nTime Complexity is O(n^3)\n***\n\n## Implementation:\n\n\n### Iterative\n```\nclass Solution:\n# @return a list of lists of length 4, [[val1,val2,val3,val4]]\ndef fourSum(self, num, target):\n    two_sum = collections.defaultdict(list)\n    res = set()\n    for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\n        two_sum[i1+i2].append({n1, n2})\n    for t in list(two_sum.keys()):\n        if not two_sum[target-t]:\n            continue\n        for pair1 in two_sum[t]:\n            for pair2 in two_sum[target-t]:\n                if pair1.isdisjoint(pair2):\n                    res.add(tuple(sorted(num[i] for i in pair1 | pair2)))\n        del two_sum[t]\n    return [list(r) for r in res]\n```\n\n***\n\n### Recursive\n```\ndef fourSum(self, nums, target):\n    nums.sort()\n    results = []\n    self.findNsum(nums, target, 4, [], results)\n    return results\n\ndef findNsum(self, nums, target, N, result, results):\n    if len(nums) < N or N < 2: return\n\n    # solve 2-sum\n    if N == 2:\n        l,r = 0,len(nums)-1\n        while l < r:\n            if nums[l] + nums[r] == target:\n                results.append(result + [nums[l], nums[r]])\n                l += 1\n                r -= 1\n                while l < r and nums[l] == nums[l - 1]:\n                    l += 1\n                while r > l and nums[r] == nums[r + 1]:\n                    r -= 1\n            elif nums[l] + nums[r] < target:\n                l += 1\n            else:\n                r -= 1\n    else:\n        for i in range(0, len(nums)-N+1):   # careful about range\n            if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\n                break\n            if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\n                self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n    return\n```\n\n***\n\n### Revised\n```\ndef fourSum(self, nums, target):\n    def findNsum(nums, target, N, result, results):\n        if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\n            return\n        if N == 2: # two pointers solve sorted 2-sum problem\n            l,r = 0,len(nums)-1\n            while l < r:\n                s = nums[l] + nums[r]\n                if s == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif s < target:\n                    l += 1\n                else:\n                    r -= 1\n        else: # recursively reduce N\n            for i in range(len(nums)-N+1):\n                if i == 0 or (i > 0 and nums[i-1] != nums[i]):\n                    findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\n\n    results = []\n    findNsum(sorted(nums), target, 4, [], results)\n    return results\n```","slug":"4Sum","published":1,"date":"2017-08-12T05:39:02.000Z","updated":"2017-08-12T06:47:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4c0001ye8r8qvo43a0"},{"title":"3Sum Closest","_content":"\n### Problem:\nGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n```\n    For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n```\n\n***\n\n### Analysis:\nSimilar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. Time Complexity is O(n^2)\n\n***\n\n### Implementation:\n```\ndef threeSum(self, nums):\n    if len(nums) <3: \n        return []\n    elif len(nums) == 3:\n        if sum(nums) == 0:\n            return [sorted(nums)]\n    nums.sort()\n    res = []\n    for i in list(range(len(nums)-2)):\n        if i > 0 and nums[i] == nums[i-1]: # avoid duplication\n            continue\n        j = i + 1\n        k = len(nums) - 1\n        while j < k:\n            if j > i + 1 and nums[j] == nums[j-1]: # avoid duplication\n                j += 1\n                continue\n            if k < len(nums) - 1 and nums[k] == nums[k+1]: # avoid duplication\n                k -= 1\n                continue\n            if nums[i] + nums[j] + nums[k] == 0:\n                res.append([nums[i],nums[j],nums[k]])\n            if nums[i] + nums[j] + nums[k] < 0:\n                j += 1\n            else:\n                k -= 1\n    return res\n```","source":"_posts/3SumClosest.md","raw":"---\ntitle: 3Sum Closest\n---\n\n### Problem:\nGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n```\n    For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n```\n\n***\n\n### Analysis:\nSimilar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. Time Complexity is O(n^2)\n\n***\n\n### Implementation:\n```\ndef threeSum(self, nums):\n    if len(nums) <3: \n        return []\n    elif len(nums) == 3:\n        if sum(nums) == 0:\n            return [sorted(nums)]\n    nums.sort()\n    res = []\n    for i in list(range(len(nums)-2)):\n        if i > 0 and nums[i] == nums[i-1]: # avoid duplication\n            continue\n        j = i + 1\n        k = len(nums) - 1\n        while j < k:\n            if j > i + 1 and nums[j] == nums[j-1]: # avoid duplication\n                j += 1\n                continue\n            if k < len(nums) - 1 and nums[k] == nums[k+1]: # avoid duplication\n                k -= 1\n                continue\n            if nums[i] + nums[j] + nums[k] == 0:\n                res.append([nums[i],nums[j],nums[k]])\n            if nums[i] + nums[j] + nums[k] < 0:\n                j += 1\n            else:\n                k -= 1\n    return res\n```","slug":"3SumClosest","published":1,"date":"2017-08-12T03:24:07.000Z","updated":"2017-08-12T05:33:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4f0002ye8rh8ea67y7"},{"title":"Add Two Numbers","_content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n### Example\n```\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n```\n***\n### Analysis\nTraverse both lists. One by one pick nodes of both lists and add the values. If sum is more than 10 then make carry as 1 and reduce sum. If one list has more elements than the other then consider remaining values of this list as 0. Following is the implementation of this approach. Time Complexity is O(m + n)\n***\n### Implementation\n```\n def addTwoNumbers(self, l1, l2):\n        carry = 0;\n        res = n = ListNode(0);\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next;\n            if l2:\n                carry += l2.val;\n                l2 = l2.next;\n            carry, val = divmod(carry, 10)\n            n.next = n = ListNode(val);\n        return res.next;\n```","source":"_posts/AddTwoNumbers.markdown","raw":"---\ntitle: Add Two Numbers\n---\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n### Example\n```\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8\n```\n***\n### Analysis\nTraverse both lists. One by one pick nodes of both lists and add the values. If sum is more than 10 then make carry as 1 and reduce sum. If one list has more elements than the other then consider remaining values of this list as 0. Following is the implementation of this approach. Time Complexity is O(m + n)\n***\n### Implementation\n```\n def addTwoNumbers(self, l1, l2):\n        carry = 0;\n        res = n = ListNode(0);\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next;\n            if l2:\n                carry += l2.val;\n                l2 = l2.next;\n            carry, val = divmod(carry, 10)\n            n.next = n = ListNode(val);\n        return res.next;\n```","slug":"AddTwoNumbers","published":1,"date":"2017-07-26T06:50:22.000Z","updated":"2017-08-07T00:08:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4h0003ye8rfw2ymayw"},{"title":"Divide Two Integers","_content":"\n### Problem:\nDivide two integers without using multiplication, division and mod operator.\n\nIf it is overflow, return MAX_INT.\n\n***\n\n### Analysis:\nIn this problem, we are asked to two integers. However, we are not allowed to use division, multiplication and mod operations. So we can use bit manipulations.\n\nSuppose we want to divide 15 by 3. so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative.\n\nWe subtract 3 from 15 and get 12 then, which is positive. Let's try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6.Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3.\n\nThen we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 << 0 to the answer.\n\nNow we have the full algorithm to perform division.\n\nAccording to the problem statement, we need to handle some exceptions, overflow.\n\n1. divisor = 0;\n2. dividend = INT_MIN and advisior = -1 (because abs(INT_MIN) = INT_MAX + 1).\n\nThe Time Complexity is O(32) which is O(1). \n\n### Implementation:\n```\nclass Solution:\n# @return an integer\ndef divide(self, dividend, divisor):\n    positive = (dividend < 0) is (divisor < 0)\n    dividend, divisor = abs(dividend), abs(divisor)\n    res = 0\n    while dividend >= divisor:\n        temp, i = divisor, 1\n        while dividend >= temp:\n            dividend -= temp\n            res += i\n            i <<= 1\n            temp <<= 1\n    if not positive:\n        res = -res\n    return min(max(-2147483648, res), 2147483647)\n```","source":"_posts/Divide Two Integers.md","raw":"---\ntitle: Divide Two Integers\n---\n\n### Problem:\nDivide two integers without using multiplication, division and mod operator.\n\nIf it is overflow, return MAX_INT.\n\n***\n\n### Analysis:\nIn this problem, we are asked to two integers. However, we are not allowed to use division, multiplication and mod operations. So we can use bit manipulations.\n\nSuppose we want to divide 15 by 3. so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative.\n\nWe subtract 3 from 15 and get 12 then, which is positive. Let's try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6.Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3.\n\nThen we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 << 0 to the answer.\n\nNow we have the full algorithm to perform division.\n\nAccording to the problem statement, we need to handle some exceptions, overflow.\n\n1. divisor = 0;\n2. dividend = INT_MIN and advisior = -1 (because abs(INT_MIN) = INT_MAX + 1).\n\nThe Time Complexity is O(32) which is O(1). \n\n### Implementation:\n```\nclass Solution:\n# @return an integer\ndef divide(self, dividend, divisor):\n    positive = (dividend < 0) is (divisor < 0)\n    dividend, divisor = abs(dividend), abs(divisor)\n    res = 0\n    while dividend >= divisor:\n        temp, i = divisor, 1\n        while dividend >= temp:\n            dividend -= temp\n            res += i\n            i <<= 1\n            temp <<= 1\n    if not positive:\n        res = -res\n    return min(max(-2147483648, res), 2147483647)\n```","slug":"Divide Two Integers","published":1,"date":"2017-08-17T05:10:23.000Z","updated":"2017-08-17T05:41:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4i0004ye8rlsxlu7ra"},{"title":"First Missing Positive","_content":"\n### Problem:\nGiven an unsorted integer array, find the first missing positive integer.\n\nFor example,\nGiven [1,2,0] return 3,\nand [3,4,-1,1] return 2.\n\nYour algorithm should run in O(n) time and uses constant space.\n\n***\n\n### Analysis:\nPut each number in its right place.\n\nFor example:\n\nWhen we find 5, then swap it with A[4].\n\nAt last, the first place where its number is not right, return the place + 1.\n\nTime Complexity is O(n) and Space complexity is O(1)\n***\n\n### Implementation:\n```\ndef firstMissingPositive(self, nums):\n    for i in xrange(len(nums)):\n        while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\n            tmp = nums[i]-1\n            nums[i], nums[tmp] = nums[tmp], nums[i]\n    for i in xrange(len(nums)):\n        if nums[i] != i+1:\n            return i+1\n    return len(nums)+1\n```","source":"_posts/First Missing Positive.md","raw":"---\ntitle: First Missing Positive\n---\n\n### Problem:\nGiven an unsorted integer array, find the first missing positive integer.\n\nFor example,\nGiven [1,2,0] return 3,\nand [3,4,-1,1] return 2.\n\nYour algorithm should run in O(n) time and uses constant space.\n\n***\n\n### Analysis:\nPut each number in its right place.\n\nFor example:\n\nWhen we find 5, then swap it with A[4].\n\nAt last, the first place where its number is not right, return the place + 1.\n\nTime Complexity is O(n) and Space complexity is O(1)\n***\n\n### Implementation:\n```\ndef firstMissingPositive(self, nums):\n    for i in xrange(len(nums)):\n        while 0 <= nums[i]-1 < len(nums) and nums[nums[i]-1] != nums[i]:\n            tmp = nums[i]-1\n            nums[i], nums[tmp] = nums[tmp], nums[i]\n    for i in xrange(len(nums)):\n        if nums[i] != i+1:\n            return i+1\n    return len(nums)+1\n```","slug":"First Missing Positive","published":1,"date":"2017-08-19T06:43:29.000Z","updated":"2017-08-19T06:56:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4l0005ye8raj1khbpu"},{"title":"Group Anagrams","_content":"\n### Problem:\nGiven an array of strings, group anagrams together.\n\n```\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\nNote: All inputs will be in lower-case.\n\n***\n\n### Analysis:\nSort each string and put it into a hashmap. The Time Complexity is O(m*nlogn)\n\n1. collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting (objects that hashes to same value)\n2. tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\n3. filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\n4. lambda function defined here returns True if number of anagrams of that elements is greater than 1\n\n***\n\n### Implementation:\n```\n   def anagrams(self, strs):\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\n```\n\nOr\n\n1. collection.defaultdict is used instead of Counter. It is almost same as dict but you can set default value (the value when item is not found in the dictionary)\n2. list comprehension is used in the return statement in order to select anagrams which have more than 1 word and also to flatten the d.values() which is list of lists\n\n```\ndef anagrams(self, strs):\n       d = collections.defaultdict(list)\n       for s in strs:\n           d[tuple(sorted(s))].append(s)  \n       return [a for agram_group in d.values() if len(agram_group)>1 for a in agram_group]\n\n```\n","source":"_posts/Group Anagrams.md","raw":"---\ntitle: Group Anagrams\n---\n\n### Problem:\nGiven an array of strings, group anagrams together.\n\n```\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n```\nNote: All inputs will be in lower-case.\n\n***\n\n### Analysis:\nSort each string and put it into a hashmap. The Time Complexity is O(m*nlogn)\n\n1. collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting (objects that hashes to same value)\n2. tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\n3. filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\n4. lambda function defined here returns True if number of anagrams of that elements is greater than 1\n\n***\n\n### Implementation:\n```\n   def anagrams(self, strs):\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\n```\n\nOr\n\n1. collection.defaultdict is used instead of Counter. It is almost same as dict but you can set default value (the value when item is not found in the dictionary)\n2. list comprehension is used in the return statement in order to select anagrams which have more than 1 word and also to flatten the d.values() which is list of lists\n\n```\ndef anagrams(self, strs):\n       d = collections.defaultdict(list)\n       for s in strs:\n           d[tuple(sorted(s))].append(s)  \n       return [a for agram_group in d.values() if len(agram_group)>1 for a in agram_group]\n\n```\n","slug":"Group Anagrams","published":1,"date":"2017-08-20T04:10:24.000Z","updated":"2017-08-20T04:15:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4m0006ye8rtfhgnqk6"},{"title":"Longest Common Prefix","_content":"\n### Problem:\nWrite a function to find the longest common prefix string amongst an array of strings.\n\n***\n\n### Analysis:\nuse two loops check from the start of both string, find the mismatch position and return. The shortest one's length is the end of the loop. Need to consider no prefix and whole match these two conditions. Time Complexity is O(kn)\n\n***\n\n### Implementation:\n\n```\n def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        shortest = min(strs,key=len)\n        for i, ch in enumerate(shortest):\n            for other in strs:\n                if other[i] != ch:\n                    return shortest[:i]\n        return shortest \n```","source":"_posts/Longest Common Prefix.md","raw":"---\ntitle: Longest Common Prefix\n---\n\n### Problem:\nWrite a function to find the longest common prefix string amongst an array of strings.\n\n***\n\n### Analysis:\nuse two loops check from the start of both string, find the mismatch position and return. The shortest one's length is the end of the loop. Need to consider no prefix and whole match these two conditions. Time Complexity is O(kn)\n\n***\n\n### Implementation:\n\n```\n def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        shortest = min(strs,key=len)\n        for i, ch in enumerate(shortest):\n            for other in strs:\n                if other[i] != ch:\n                    return shortest[:i]\n        return shortest \n```","slug":"Longest Common Prefix","published":1,"date":"2017-08-14T02:46:44.000Z","updated":"2017-08-15T05:45:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4n0007ye8rrfqzwwym"},{"title":"Longest Palindromic Substring","_content":"### Problem:\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\nExample:\n\n```\nInput: \"babad\"\n\nOutput: \"bab\"\n\nNote: \"aba\" is also a valid answer.\n```\n\n\nExample:\n\n```\nInput: \"cbbd\"\n\nOutput: \"bb\"\n```\n---\n## Spread From Center:\nstart from the center of the string, spread to two ends. The process is same as the brute force. Check both odd and even cases and calculate the longest palindrome. Time Complexity O(n^2) space O(1)\n\n\n```\ndef longestPalindrome(self, s):\n    res = \"\"\n    for i in xrange(len(s)):\n        # odd case, like \"aba\"\n        tmp = self.helper(s, i, i)\n        if len(tmp) > len(res):\n            res = tmp\n        # even case, like \"abba\"\n        tmp = self.helper(s, i, i+1)\n        if len(tmp) > len(res):\n            res = tmp\n    return res\n \n# get the longest palindrome, l, r are the middle indexes   \n# from inner to outer\ndef helper(self, s, l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1; r += 1\n    return s[l+1:r]\n```\n\n---\n## Dynamic Programming\nif a long string is a palindrome, his specific substrings are also palindrome. For example, ABCCBA is a palindrome. BCCB is also a palindrome. So first we can calculate the strings whose length is 1. Then calculate the strings whose length is 2. When we calculate the strings whose length is 3 just use 1's string and 2's string. Repeat this process until find the longest one.Time Complexity is O(n^2), Space is O(n^2)\n\n\n```\nclass Solution:\n    # @return a string\n    def longestPalindrome(self, s):\n        if len(s)==0:\n        \treturn 0\n        maxLen=1\n        start=0\n        for i in xrange(len(s)):\n        \tif i-maxLen >=1 and s[i-maxLen-1:i+1] == s[i-maxLen-1:i+1][::-1]:\n        \t\tstart=i-maxLen-1\n        \t\tmaxLen+=2\n        \t\tcontinue\n\n        \tif i-maxLen >=0 and s[i-maxLen:i+1] == s[i-maxLen:i+1][::-1]:\n        \t\tstart=i-maxLen\n        \t\tmaxLen+=1\n        return s[start:start+maxLen]\n```\n\n---\n## Manacher Algorithm\n\n\nTime Complexity is O(n) space is O(n)\n\n---\n## Follow Up\nQ: if only can delete the character at the front of the string. find the lease number of the delete characters.\nA: find the longest palindrome and calculate the difference. \n\n\n","source":"_posts/Longest Palindromic Substring.md","raw":"---\ntitle: Longest Palindromic Substring\n---\n### Problem:\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\nExample:\n\n```\nInput: \"babad\"\n\nOutput: \"bab\"\n\nNote: \"aba\" is also a valid answer.\n```\n\n\nExample:\n\n```\nInput: \"cbbd\"\n\nOutput: \"bb\"\n```\n---\n## Spread From Center:\nstart from the center of the string, spread to two ends. The process is same as the brute force. Check both odd and even cases and calculate the longest palindrome. Time Complexity O(n^2) space O(1)\n\n\n```\ndef longestPalindrome(self, s):\n    res = \"\"\n    for i in xrange(len(s)):\n        # odd case, like \"aba\"\n        tmp = self.helper(s, i, i)\n        if len(tmp) > len(res):\n            res = tmp\n        # even case, like \"abba\"\n        tmp = self.helper(s, i, i+1)\n        if len(tmp) > len(res):\n            res = tmp\n    return res\n \n# get the longest palindrome, l, r are the middle indexes   \n# from inner to outer\ndef helper(self, s, l, r):\n    while l >= 0 and r < len(s) and s[l] == s[r]:\n        l -= 1; r += 1\n    return s[l+1:r]\n```\n\n---\n## Dynamic Programming\nif a long string is a palindrome, his specific substrings are also palindrome. For example, ABCCBA is a palindrome. BCCB is also a palindrome. So first we can calculate the strings whose length is 1. Then calculate the strings whose length is 2. When we calculate the strings whose length is 3 just use 1's string and 2's string. Repeat this process until find the longest one.Time Complexity is O(n^2), Space is O(n^2)\n\n\n```\nclass Solution:\n    # @return a string\n    def longestPalindrome(self, s):\n        if len(s)==0:\n        \treturn 0\n        maxLen=1\n        start=0\n        for i in xrange(len(s)):\n        \tif i-maxLen >=1 and s[i-maxLen-1:i+1] == s[i-maxLen-1:i+1][::-1]:\n        \t\tstart=i-maxLen-1\n        \t\tmaxLen+=2\n        \t\tcontinue\n\n        \tif i-maxLen >=0 and s[i-maxLen:i+1] == s[i-maxLen:i+1][::-1]:\n        \t\tstart=i-maxLen\n        \t\tmaxLen+=1\n        return s[start:start+maxLen]\n```\n\n---\n## Manacher Algorithm\n\n\nTime Complexity is O(n) space is O(n)\n\n---\n## Follow Up\nQ: if only can delete the character at the front of the string. find the lease number of the delete characters.\nA: find the longest palindrome and calculate the difference. \n\n\n","slug":"Longest Palindromic Substring","published":1,"date":"2017-08-08T08:07:38.000Z","updated":"2017-08-08T08:07:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4o0008ye8rpxe2ftcq"},{"title":"Longest Substring Without Repeating Characters","_content":"Given a string, find the length of the longest substring without repeating characters.\n\n### Examples:\n\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\n\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n***\n\n### Analysis\nAccording to the definition of the longest unambiguous sub-string, we will encounter the characters in the current substring when traversing the string, and the new substring should start from the next bit of the repeat point.\n\nSo in order to find the maximum length in a traversal, we need to record two things. The first is whether a letter appears in the current substring or not, and the second is what happens if it appears in the string. The easiest way to determine whether a character is present in the current substring is to see if it was the last occurrence of the first character of the current substring or the back of the first character, so we just record the character last position can meet both requirements at the same time. \n\nHash table is the most natural idea. When traversing the string, we first find out the last occurrence of the character based on the hash table, and if it is greater than or equal to the substring, update the substring first. Because it is equivalent to a sub-string has ended, we have to update the maximum length. After the end of the character, put the new position into the hash table. Time complexity is O(n) and Space complexity is O(n)\n\n### Tips\n* 1 After finish the traverse, need to update the max length and consider the max length string at the end of the source string\n\n* 2 The substring start index should be the duplicate element's index + 1\n\n* 3 The input string might be null or empty\n\n***\n\n### Implementation\n```\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        start = maxLength = 0\n        usedChar = {}\n\n        for i in range(len(s)):\n            if s[i] in usedChar and start <= usedChar[s[i]]:\n                start = usedChar[s[i]] + 1\n            else:\n                maxLength = max(maxLength, i - start + 1)\n\n            usedChar[s[i]] = i\n\n        return maxLength\n```","source":"_posts/Longest Substring Without Repeating Characters.markdown","raw":"---\ntitle: Longest Substring Without Repeating Characters\n---\nGiven a string, find the length of the longest substring without repeating characters.\n\n### Examples:\n\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\n\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n***\n\n### Analysis\nAccording to the definition of the longest unambiguous sub-string, we will encounter the characters in the current substring when traversing the string, and the new substring should start from the next bit of the repeat point.\n\nSo in order to find the maximum length in a traversal, we need to record two things. The first is whether a letter appears in the current substring or not, and the second is what happens if it appears in the string. The easiest way to determine whether a character is present in the current substring is to see if it was the last occurrence of the first character of the current substring or the back of the first character, so we just record the character last position can meet both requirements at the same time. \n\nHash table is the most natural idea. When traversing the string, we first find out the last occurrence of the character based on the hash table, and if it is greater than or equal to the substring, update the substring first. Because it is equivalent to a sub-string has ended, we have to update the maximum length. After the end of the character, put the new position into the hash table. Time complexity is O(n) and Space complexity is O(n)\n\n### Tips\n* 1 After finish the traverse, need to update the max length and consider the max length string at the end of the source string\n\n* 2 The substring start index should be the duplicate element's index + 1\n\n* 3 The input string might be null or empty\n\n***\n\n### Implementation\n```\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        start = maxLength = 0\n        usedChar = {}\n\n        for i in range(len(s)):\n            if s[i] in usedChar and start <= usedChar[s[i]]:\n                start = usedChar[s[i]] + 1\n            else:\n                maxLength = max(maxLength, i - start + 1)\n\n            usedChar[s[i]] = i\n\n        return maxLength\n```","slug":"Longest Substring Without Repeating Characters","published":1,"date":"2017-08-08T08:07:38.000Z","updated":"2017-08-08T08:07:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4p0009ye8ruldw9hej"},{"title":"Maximum Subarray","_content":"\n### Problem:\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\n\n***\n\n### Analysis:\nApparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation.\n\nAt first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one.\n\nSo I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\n\nmaxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \n\n***\n\n### implementation:\n```\nclass Solution:\n    # @param A, a list of integers\n    # @return an integer\n    # 6:57\n    def maxSubArray(self, A):\n        for i in xrange(1,len(nums)):\n                nums[i] = max(nums[i - 1] + nums[i], nums[i])\n        return max(nums)\n```","source":"_posts/Maximum Subarray.md","raw":"---\ntitle: Maximum Subarray\n---\n\n### Problem:\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\n\n***\n\n### Analysis:\nApparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation.\n\nAt first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one.\n\nSo I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\n\nmaxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \n\n***\n\n### implementation:\n```\nclass Solution:\n    # @param A, a list of integers\n    # @return an integer\n    # 6:57\n    def maxSubArray(self, A):\n        for i in xrange(1,len(nums)):\n                nums[i] = max(nums[i - 1] + nums[i], nums[i])\n        return max(nums)\n```","slug":"Maximum Subarray","published":1,"date":"2017-08-20T04:16:19.000Z","updated":"2017-08-20T04:21:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4p000aye8rsw962g4r"},{"title":"Merge Two Sorted Lists","_content":"\n### Problem:\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n***\n\n### Ayalysis:\nBasic idea is start from a List, growing it node by node.\n\nIn solutions we have a dummy head, and a tail called current indicating last node in this growing List. At each step we append either l1 or l2 to tail, and update tail, l1 or l2 accordingly.\n\nTime Complexity is O(m + n)\n\n***\n\n### Implementation:\n\nIteratively\n```\ndef mergeTwoLists1(self, l1, l2):\n    dummy = cur = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 or l2\n    return dummy.next\n```\n\n\nRecursively\n```\ndef mergeTwoLists2(self, l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = self.mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = self.mergeTwoLists(l1, l2.next)\n        return l2\n```\n\nIteratively （In place）\n```\ndef mergeTwoLists(self, l1, l2):\n    if None in (l1, l2):\n        return l1 or l2\n    dummy = cur = ListNode(0)\n    dummy.next = l1\n    while l1 and l2:\n        if l1.val < l2.val:\n            l1 = l1.next\n        else:\n            nxt = cur.next\n            cur.next = l2\n            tmp = l2.next\n            l2.next = nxt\n            l2 = tmp\n        cur = cur.next\n    cur.next = l1 or l2\n    return dummy.next\n```\n","source":"_posts/Merge Two Sorted Lists.md","raw":"---\ntitle: Merge Two Sorted Lists\n---\n\n### Problem:\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n***\n\n### Ayalysis:\nBasic idea is start from a List, growing it node by node.\n\nIn solutions we have a dummy head, and a tail called current indicating last node in this growing List. At each step we append either l1 or l2 to tail, and update tail, l1 or l2 accordingly.\n\nTime Complexity is O(m + n)\n\n***\n\n### Implementation:\n\nIteratively\n```\ndef mergeTwoLists1(self, l1, l2):\n    dummy = cur = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 or l2\n    return dummy.next\n```\n\n\nRecursively\n```\ndef mergeTwoLists2(self, l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = self.mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = self.mergeTwoLists(l1, l2.next)\n        return l2\n```\n\nIteratively （In place）\n```\ndef mergeTwoLists(self, l1, l2):\n    if None in (l1, l2):\n        return l1 or l2\n    dummy = cur = ListNode(0)\n    dummy.next = l1\n    while l1 and l2:\n        if l1.val < l2.val:\n            l1 = l1.next\n        else:\n            nxt = cur.next\n            cur.next = l2\n            tmp = l2.next\n            l2.next = nxt\n            l2 = tmp\n        cur = cur.next\n    cur.next = l1 or l2\n    return dummy.next\n```\n","slug":"Merge Two Sorted Lists","published":1,"date":"2017-08-19T06:11:57.000Z","updated":"2017-08-19T06:43:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4q000bye8rxyxn7vna"},{"title":"Multiply Strings","_content":"\n### Problem:\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n***\n\n### Analysis:\n1. reverse the string\n2. create an array and store the product in right position\n3. take care the carrier\n4. deal with corner case\n\nThe Time Complexity is O(m * n), Space Complexity is O(m + n)\n***\n\n### Implementation:\n```\ndef multiply(num1, num2):\n    product = [0] * (len(num1) + len(num2))\n    pos = len(product)-1\n    \n    for n1 in reversed(num1):\n        tempPos = pos\n        for n2 in reversed(num2):\n            product[tempPos] += int(n1) * int(n2)\n            product[tempPos-1] += product[tempPos]/10\n            product[tempPos] %= 10\n            tempPos -= 1\n        pos -= 1\n        \n    pt = 0\n    while pt < len(product)-1 and product[pt] == 0:\n        pt += 1\n\n    return ''.join(map(str, product[pt:]))\n```","source":"_posts/Multiply Strings.md","raw":"---\ntitle: Multiply Strings\n---\n\n### Problem:\nGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n***\n\n### Analysis:\n1. reverse the string\n2. create an array and store the product in right position\n3. take care the carrier\n4. deal with corner case\n\nThe Time Complexity is O(m * n), Space Complexity is O(m + n)\n***\n\n### Implementation:\n```\ndef multiply(num1, num2):\n    product = [0] * (len(num1) + len(num2))\n    pos = len(product)-1\n    \n    for n1 in reversed(num1):\n        tempPos = pos\n        for n2 in reversed(num2):\n            product[tempPos] += int(n1) * int(n2)\n            product[tempPos-1] += product[tempPos]/10\n            product[tempPos] %= 10\n            tempPos -= 1\n        pos -= 1\n        \n    pt = 0\n    while pt < len(product)-1 and product[pt] == 0:\n        pt += 1\n\n    return ''.join(map(str, product[pt:]))\n```","slug":"Multiply Strings","published":1,"date":"2017-08-22T06:02:18.000Z","updated":"2017-08-22T06:18:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4s000cye8rds970ida"},{"title":"Next Permutation","_content":"\n### Problem:\nmplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place, do not allocate extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\n***\n\n### Analysis:\nThe key observation in this algorithm is that when we want to compute the next permutation, we must “increase” the sequence as little as possible. Just like when we count up using numbers, we try to modify the rightmost elements and leave the left side unchanged. For example, there is no need to change the first element from 0 to 1, because by changing the prefix from (0, 1) to (0, 2) we get an even closer next permutation. In fact, there is no need to change the second element either, which brings us to the next point.\n\nFirstly, identify the longest suffix that is non-increasing (i.e. weakly decreasing). In our example, the suffix with this property is (5, 3, 3, 0). This suffix is already the highest permutation, so we can’t make a next permutation just by modifying it – we need to modify some element(s) to the left of it. (Note that we can identify this suffix in O(n) time by scanning the sequence from right to left. Also note that such a suffix has at least one element, because a single element substring is trivially non-increasing.)\n\nSecondly, look at the element immediately to the left of the suffix (in the example it’s 2) and call it the pivot. (If there is no such element – i.e. the entire sequence is non-decreasing – then this is already the last permutation.) The pivot is necessarily less than the head of the suffix (in the example it’s 5). So some element in the suffix is greater than the pivot. If we swap the pivot with the smallest element in the suffix that is greater than the pivot, then the prefix is minimized. (The prefix is everything in the sequence except the suffix.) In the example, we end up with the new prefix (0, 1, 3) and new suffix (5, 3, 2, 0). (Note that if the suffix has multiple copies of the new pivot, we should take the rightmost copy – this plays into the next step.)\n\nFinally, we sort the suffix in non-decreasing (i.e. weakly increasing) order because we increased the prefix, so we want to make the new suffix as low as possible. In fact, we can avoid sorting and simply reverse the suffix, because the replaced element respects the weakly decreasing order. Thus we obtain the sequence (0, 1, 3, 0, 2, 3, 5), which is the next permutation that we wanted to compute.\n\nCondensed mathematical description:\n\nFind largest index i such that array[i − 1] < array[i].\n(If no such i exists, then this is already the last permutation.)\n\nFind largest index j such that j ≥ i and array[j] > array[i − 1].\n\nSwap array[j] and array[i − 1].\n\nReverse the suffix starting at array[i].\n\nTime Complexity is O(n)\n\nReference: https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\n\n***\n\n### Implementation:\n```\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # find longest non-increasing suffix\n        right = len(nums)-1\n        while nums[right] <= nums[right-1] and right-1 >=0:\n            right -= 1\n        if right == 0:\n            return self.reverse(nums,0,len(nums)-1)\n        # find pivot\n        pivot = right-1\n        successor = 0\n        # find rightmost succesor\n        for i in range(len(nums)-1,pivot,-1):\n            if nums[i] > nums[pivot]:\n                successor = i\n                break\n        # swap pivot and successor\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \n        # reverse suffix\n        self.reverse(nums,pivot+1,len(nums)-1)\n        \n    def reverse(self,nums,l,r):\n        while l < r:\n            nums[l],nums[r] = nums[r],nums[l]\n            l += 1\n            r -= 1\n```","source":"_posts/Next Permutation.md","raw":"---\ntitle: Next Permutation\n---\n\n### Problem:\nmplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place, do not allocate extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\n***\n\n### Analysis:\nThe key observation in this algorithm is that when we want to compute the next permutation, we must “increase” the sequence as little as possible. Just like when we count up using numbers, we try to modify the rightmost elements and leave the left side unchanged. For example, there is no need to change the first element from 0 to 1, because by changing the prefix from (0, 1) to (0, 2) we get an even closer next permutation. In fact, there is no need to change the second element either, which brings us to the next point.\n\nFirstly, identify the longest suffix that is non-increasing (i.e. weakly decreasing). In our example, the suffix with this property is (5, 3, 3, 0). This suffix is already the highest permutation, so we can’t make a next permutation just by modifying it – we need to modify some element(s) to the left of it. (Note that we can identify this suffix in O(n) time by scanning the sequence from right to left. Also note that such a suffix has at least one element, because a single element substring is trivially non-increasing.)\n\nSecondly, look at the element immediately to the left of the suffix (in the example it’s 2) and call it the pivot. (If there is no such element – i.e. the entire sequence is non-decreasing – then this is already the last permutation.) The pivot is necessarily less than the head of the suffix (in the example it’s 5). So some element in the suffix is greater than the pivot. If we swap the pivot with the smallest element in the suffix that is greater than the pivot, then the prefix is minimized. (The prefix is everything in the sequence except the suffix.) In the example, we end up with the new prefix (0, 1, 3) and new suffix (5, 3, 2, 0). (Note that if the suffix has multiple copies of the new pivot, we should take the rightmost copy – this plays into the next step.)\n\nFinally, we sort the suffix in non-decreasing (i.e. weakly increasing) order because we increased the prefix, so we want to make the new suffix as low as possible. In fact, we can avoid sorting and simply reverse the suffix, because the replaced element respects the weakly decreasing order. Thus we obtain the sequence (0, 1, 3, 0, 2, 3, 5), which is the next permutation that we wanted to compute.\n\nCondensed mathematical description:\n\nFind largest index i such that array[i − 1] < array[i].\n(If no such i exists, then this is already the last permutation.)\n\nFind largest index j such that j ≥ i and array[j] > array[i − 1].\n\nSwap array[j] and array[i − 1].\n\nReverse the suffix starting at array[i].\n\nTime Complexity is O(n)\n\nReference: https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\n\n***\n\n### Implementation:\n```\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # find longest non-increasing suffix\n        right = len(nums)-1\n        while nums[right] <= nums[right-1] and right-1 >=0:\n            right -= 1\n        if right == 0:\n            return self.reverse(nums,0,len(nums)-1)\n        # find pivot\n        pivot = right-1\n        successor = 0\n        # find rightmost succesor\n        for i in range(len(nums)-1,pivot,-1):\n            if nums[i] > nums[pivot]:\n                successor = i\n                break\n        # swap pivot and successor\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \n        # reverse suffix\n        self.reverse(nums,pivot+1,len(nums)-1)\n        \n    def reverse(self,nums,l,r):\n        while l < r:\n            nums[l],nums[r] = nums[r],nums[l]\n            l += 1\n            r -= 1\n```","slug":"Next Permutation","published":1,"date":"2017-08-18T05:56:25.000Z","updated":"2017-08-18T06:29:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4s000dye8rlqwt1f1w"},{"title":"Permutations","_content":"\n### Problem:\nGiven a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n```\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n***\n\n### Analysis:\nthe basic idea is, to permute n numbers, we can add the nth number into the resulting [[]] from the n-1 numbers, in every possible position.\n\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial [[]] (let's call it \"result\").\n\nThen, 2 can be added in front or after 1. So we have to copy the [] in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\n\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\n\nThe Time Complexity is O(n!)\n***\n\n### Implementation:\n```\ndef permute(self, nums):\n    perms = [[]]   \n    for n in nums:\n        new_perms = []\n        for perm in perms:\n            for i in xrange(len(perm)+1):   \n                new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\n        perms = new_perms\n    return perms\n```\n\n","source":"_posts/Permutations.md","raw":"---\ntitle: Permutations\n---\n\n### Problem:\nGiven a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n```\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n***\n\n### Analysis:\nthe basic idea is, to permute n numbers, we can add the nth number into the resulting [[]] from the n-1 numbers, in every possible position.\n\nFor example, if the input num[] is {1,2,3}: First, add 1 into the initial [[]] (let's call it \"result\").\n\nThen, 2 can be added in front or after 1. So we have to copy the [] in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.\n\nThen we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.\n\nThe Time Complexity is O(n!)\n***\n\n### Implementation:\n```\ndef permute(self, nums):\n    perms = [[]]   \n    for n in nums:\n        new_perms = []\n        for perm in perms:\n            for i in xrange(len(perm)+1):   \n                new_perms.append(perm[:i] + [n] + perm[i:])   ###insert n\n        perms = new_perms\n    return perms\n```\n\n","slug":"Permutations","published":1,"date":"2017-08-22T06:26:25.000Z","updated":"2017-08-22T06:38:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4t000eye8rgi88ddnh"},{"title":"Remove Duplicates from Sorted Array","_content":"\n### Problem:\nGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nFor example,\nGiven input array nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.\n\n***\n\n### Analysis:\nStart from new index newTail=0, only put the number is larger than nums[newTail], then update newTail and nums[newTail]. repeat the process to find the result. The Time Complexity is O(n), Space Complexity is O(1).\n***\n\n### Implementation:\n```\nclass Solution:\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        newTail = 0\n\n        for i in range(1, len(A)):\n            if A[i] != A[newTail]:\n                newTail += 1\n                A[newTail] = A[i]\n\n        return newTail + 1\n```","source":"_posts/Remove Duplicates from Sorted Array.md","raw":"---\ntitle: Remove Duplicates from Sorted Array\n---\n\n### Problem:\nGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nFor example,\nGiven input array nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.\n\n***\n\n### Analysis:\nStart from new index newTail=0, only put the number is larger than nums[newTail], then update newTail and nums[newTail]. repeat the process to find the result. The Time Complexity is O(n), Space Complexity is O(1).\n***\n\n### Implementation:\n```\nclass Solution:\n    # @param a list of integers\n    # @return an integer\n    def removeDuplicates(self, A):\n        if not A:\n            return 0\n\n        newTail = 0\n\n        for i in range(1, len(A)):\n            if A[i] != A[newTail]:\n                newTail += 1\n                A[newTail] = A[i]\n\n        return newTail + 1\n```","slug":"Remove Duplicates from Sorted Array","published":1,"date":"2017-08-16T06:09:31.000Z","updated":"2017-08-16T06:21:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4w000fye8rrm5wor1w"},{"title":"Remove Element.md","_content":"\n### Problem:\nGiven an array and a value, remove all instances of that value in place and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nExample:\nGiven input array nums = [3,2,2,3], val = 3\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\n***\n\n### Analysis:\nStarting from the left every time, we find a value that is the target value. So swap it out with an item starting from the right. We decrement end each time. As we know that the final item is the target value and only increment start when we know the value is ok. when start reaches end we know all items after that point are the target value so we can stop there. Time Complexity is O(n) and Space Complexity is O(1).\n\n***\n\n### Implementation:\n```\n  def removeElement(self, nums, val):\n    start, end = 0, len(nums) - 1\n    while start <= end:\n        if nums[start] == val:\n            nums[start], nums[end], end = nums[end], nums[start], end - 1\n        else:\n            start +=1\n    return start\n```","source":"_posts/Remove Element.md","raw":"---\ntitle: Remove Element.md\n---\n\n### Problem:\nGiven an array and a value, remove all instances of that value in place and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nExample:\nGiven input array nums = [3,2,2,3], val = 3\n\nYour function should return length = 2, with the first two elements of nums being 2.\n\n***\n\n### Analysis:\nStarting from the left every time, we find a value that is the target value. So swap it out with an item starting from the right. We decrement end each time. As we know that the final item is the target value and only increment start when we know the value is ok. when start reaches end we know all items after that point are the target value so we can stop there. Time Complexity is O(n) and Space Complexity is O(1).\n\n***\n\n### Implementation:\n```\n  def removeElement(self, nums, val):\n    start, end = 0, len(nums) - 1\n    while start <= end:\n        if nums[start] == val:\n            nums[start], nums[end], end = nums[end], nums[start], end - 1\n        else:\n            start +=1\n    return start\n```","slug":"Remove Element","published":1,"date":"2017-08-17T04:48:23.000Z","updated":"2017-08-17T05:41:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4x000gye8rgbw87ck1"},{"title":"Remove Nth Node From End of List","_content":"\n### Problem:\n\nGiven a linked list, remove the nth node from the end of list and return its head.\n\n```\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\n```\n\nNote:\nGiven n will always be valid.\n\nTry to do this in one pass.\n\n***\n\n### Analysis:\n\nA one pass solution can be done using pointers. Move one pointer fast --> n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node.\n\nSince the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary. Time Complexity is O(n)\n\n***\n\n### Implementation:\n```\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        fast = slow = head\n        for _ in range(n):\n            fast = fast.next\n        if not fast:\n            return head.next\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return head\n```\n\n### Reference\nhttps://discuss.leetcode.com/topic/14692/3-short-python-solutions","source":"_posts/Remove Nth Node From End of List.md","raw":"---\ntitle: Remove Nth Node From End of List\n---\n\n### Problem:\n\nGiven a linked list, remove the nth node from the end of list and return its head.\n\n```\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\n```\n\nNote:\nGiven n will always be valid.\n\nTry to do this in one pass.\n\n***\n\n### Analysis:\n\nA one pass solution can be done using pointers. Move one pointer fast --> n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node.\n\nSince the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary. Time Complexity is O(n)\n\n***\n\n### Implementation:\n```\nclass Solution:\n    def removeNthFromEnd(self, head, n):\n        fast = slow = head\n        for _ in range(n):\n            fast = fast.next\n        if not fast:\n            return head.next\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return head\n```\n\n### Reference\nhttps://discuss.leetcode.com/topic/14692/3-short-python-solutions","slug":"Remove Nth Node From End of List","published":1,"date":"2017-08-15T05:36:01.000Z","updated":"2017-08-15T06:02:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4y000hye8rtb969o0e"},{"title":"Reverse Integer","_content":"### Problem\n\nReverse digits of an integer.\n\nExample1: x = 123, return 321\nExample2: x = -123, return -321\n\nNote:\nThe input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.\n\n***\n\n### Analysis:\nGet the sign, get the reversed absolute integer, and return their product if r didn't \"overflow\".\n\n***\n\n### Implementation\n```\ndef reverse(self, x):\n    s = cmp(x, 0)\n    r = int(`s*x`[::-1])\n    return s*r * (r < 2**31)\n```","source":"_posts/Reverse Integer.md","raw":"---\ntitle: Reverse Integer\n---\n### Problem\n\nReverse digits of an integer.\n\nExample1: x = 123, return 321\nExample2: x = -123, return -321\n\nNote:\nThe input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.\n\n***\n\n### Analysis:\nGet the sign, get the reversed absolute integer, and return their product if r didn't \"overflow\".\n\n***\n\n### Implementation\n```\ndef reverse(self, x):\n    s = cmp(x, 0)\n    r = int(`s*x`[::-1])\n    return s*r * (r < 2**31)\n```","slug":"Reverse Integer","published":1,"date":"2017-08-10T05:13:38.000Z","updated":"2017-08-10T06:01:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4y000iye8rq8ypo732"},{"title":"String to Integer","_content":"\n### Problem:\nImplement atoi to convert a string to an integer.\n\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\n\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.\n\nUpdate (2015-02-10):\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.\n\n***\n\n### Analysis:\nStraight forward solution. Traverse the string from left to right, assume ret is the result. if current digit is number, ret = ret * 10  + current digit's value. if not, move to next position. Repeat until all characters have been processed. Time Complexity is O(n). Need to consider ret is overflow.\n\n\n***\n\n### Implementation:\n```\nclass Solution(object):\n    def myAtoi(self, s):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        ###better to do strip before sanity check (although 8ms slower):\n        #ls = list(s.strip())\n        #if len(ls) == 0 : return 0\n        if len(s) == 0 : return 0\n        ls = list(s.strip())\n        \n        sign = -1 if ls[0] == '-' else 1\n        if ls[0] in ['-','+'] : del ls[0]\n        ret, i = 0, 0\n        while i < len(ls) and ls[i].isdigit() :\n            ret = ret*10 + ord(ls[i]) - ord('0')\n            i += 1\n        return max(-2**31, min(sign * ret,2**31-1))\n```","source":"_posts/String to Integer.md","raw":"---\ntitle: String to Integer\n---\n\n### Problem:\nImplement atoi to convert a string to an integer.\n\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\n\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.\n\nUpdate (2015-02-10):\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.\n\n***\n\n### Analysis:\nStraight forward solution. Traverse the string from left to right, assume ret is the result. if current digit is number, ret = ret * 10  + current digit's value. if not, move to next position. Repeat until all characters have been processed. Time Complexity is O(n). Need to consider ret is overflow.\n\n\n***\n\n### Implementation:\n```\nclass Solution(object):\n    def myAtoi(self, s):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        ###better to do strip before sanity check (although 8ms slower):\n        #ls = list(s.strip())\n        #if len(ls) == 0 : return 0\n        if len(s) == 0 : return 0\n        ls = list(s.strip())\n        \n        sign = -1 if ls[0] == '-' else 1\n        if ls[0] in ['-','+'] : del ls[0]\n        ret, i = 0, 0\n        while i < len(ls) and ls[i].isdigit() :\n            ret = ret*10 + ord(ls[i]) - ord('0')\n            i += 1\n        return max(-2**31, min(sign * ret,2**31-1))\n```","slug":"String to Integer","published":1,"date":"2017-08-10T05:42:00.000Z","updated":"2017-08-10T06:00:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz4z000jye8rhurhv7du"},{"title":"Two Sum","_content":"### Problem:\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n### Example:\n\n```\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n***\n\n### Analysis:\nA hash table is built exactly for this purpose, it supports fast look up in near constant time. I say \"near\" because if a collision occurred, a look up could degenerate to O(n) time. But look up in hash table should be amortized O(1)time as long as the hash function was chosen carefully.\n\nWhile we iterate and inserting elements into the table, we also look back to check if current element's complement already exists in the table. If it exists, we have found a solution and return immediately.\n\n***\n\n### HashMap:\nTime Complexity\nO(n) one pass We traverse the list containing n elements only once. Each look up in the table costs only O(1) time.\nSpace Complexity\nO(n) The extra space required depends on the number of items stored in the hash table, which stores at most n elements.\n\n***\n### Implementation\n```\ndef twoSum(self, nums, target):\n        d={}\n        for i,num in enumerate(nums):\n            if target-num in d:\n                return d[target-num]+1, i+1\n            d[num]=i\n```\n\n***\n### Follow up:\nWhat if the element is between 0~9\n\n\n\n\n","source":"_posts/TwoSum.md","raw":"---\ntitle: Two Sum\n---\n### Problem:\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n### Example:\n\n```\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n***\n\n### Analysis:\nA hash table is built exactly for this purpose, it supports fast look up in near constant time. I say \"near\" because if a collision occurred, a look up could degenerate to O(n) time. But look up in hash table should be amortized O(1)time as long as the hash function was chosen carefully.\n\nWhile we iterate and inserting elements into the table, we also look back to check if current element's complement already exists in the table. If it exists, we have found a solution and return immediately.\n\n***\n\n### HashMap:\nTime Complexity\nO(n) one pass We traverse the list containing n elements only once. Each look up in the table costs only O(1) time.\nSpace Complexity\nO(n) The extra space required depends on the number of items stored in the hash table, which stores at most n elements.\n\n***\n### Implementation\n```\ndef twoSum(self, nums, target):\n        d={}\n        for i,num in enumerate(nums):\n            if target-num in d:\n                return d[target-num]+1, i+1\n            d[num]=i\n```\n\n***\n### Follow up:\nWhat if the element is between 0~9\n\n\n\n\n","slug":"TwoSum","published":1,"date":"2017-08-06T23:44:02.000Z","updated":"2017-08-07T00:07:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz50000kye8rl5j4scbo"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-07-23T22:39:43.000Z","updated":"2017-07-23T22:39:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6n7zz51000lye8r30newjoj"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}